<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>æŠ€èƒ½äº”å­æ£‹ v3 â€” åœ¨çº¿å¯¹æˆ˜</title>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <script>
    // PeerJS config with public STUN servers
    const PEER_CONFIG = {
      debug: 0,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' }
        ]
      }
    };
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;600;700;900&display=swap');

    :root {
      --board: #dcb468;
      --bg: #1a1612;
      --card: #2a2420;
      --card2: #342e28;
      --text: #f5efe6;
      --muted: #a89880;
      --accent: #e8a849;
      --win-glow: #ff6b35;
      --green: #4caf50;
      --red: #e74c3c;
      --blue: #5b9bd5;
      --purple: #a855f7;
      --ice: #60c0e8;
      --shield: #ffd700;
      --rain: #4fa8e0;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none
    }

    html {
      height: 100%;
      height: -webkit-fill-available
    }

    body {
      font-family: 'Noto Sans SC', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100dvh;
      min-height: -webkit-fill-available;
      overflow: hidden;
      padding-top: var(--safe-top);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
      padding-right: var(--safe-right);
    }

    /* â”€â”€ Lobby â”€â”€ */
    .lobby {
      position: fixed;
      inset: 0;
      z-index: 200;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity .4s;
      padding: max(16px, var(--safe-top)) 16px max(16px, var(--safe-bottom));
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .lobby.hidden {
      opacity: 0;
      pointer-events: none
    }

    .lc {
      background: var(--card);
      border-radius: 20px;
      padding: 26px 22px;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .5);
      text-align: center
    }

    .lc h1 {
      font-size: 1.45rem;
      font-weight: 700;
      letter-spacing: 3px;
      color: var(--accent);
      margin-bottom: 2px
    }

    .lc .sub {
      font-size: .68rem;
      color: var(--muted);
      letter-spacing: 1px;
      margin-bottom: 18px
    }

    .ls {
      margin-bottom: 14px;
      text-align: left
    }

    .ls h3 {
      font-size: .8rem;
      font-weight: 600;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 6px
    }

    .lr {
      display: flex;
      gap: 8px
    }

    .li {
      flex: 1;
      padding: 10px 14px;
      border: 2px solid var(--card2);
      border-radius: 10px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: .95rem;
      font-weight: 700;
      letter-spacing: 3px;
      text-align: center;
      outline: none;
      transition: border-color .2s;
      -webkit-appearance: none
    }

    .li:focus {
      border-color: var(--accent)
    }

    .li::placeholder {
      color: var(--muted);
      font-weight: 400;
      letter-spacing: 0;
      font-size: .78rem
    }

    .lb {
      padding: 10px 18px;
      border: none;
      border-radius: 10px;
      font-family: inherit;
      font-size: .8rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform .15s;
      white-space: nowrap;
      -webkit-appearance: none
    }

    .lb:active {
      transform: scale(.96)
    }

    .lb:disabled {
      opacity: .4;
      cursor: not-allowed
    }

    .lb.p {
      background: var(--accent);
      color: var(--bg)
    }

    .lb.s {
      background: var(--card2);
      color: var(--text)
    }

    .dv {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 14px 0;
      color: var(--muted);
      font-size: .7rem
    }

    .dv::before,
    .dv::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--card2)
    }

    .rcd {
      background: var(--bg);
      border: 2px dashed var(--accent);
      border-radius: 12px;
      padding: 12px;
      margin: 8px 0;
      text-align: center
    }

    .rcd .code {
      font-size: 1.6rem;
      font-weight: 900;
      letter-spacing: 6px;
      color: var(--accent);
      font-family: monospace
    }

    .rcd .hint {
      font-size: .68rem;
      color: var(--muted);
      margin-top: 3px
    }

    .sm {
      padding: 8px 12px;
      border-radius: 10px;
      font-size: .76rem;
      margin-top: 8px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px
    }

    .sm.info {
      background: rgba(91, 155, 213, .15);
      color: var(--blue)
    }

    .sm.err {
      background: rgba(231, 76, 60, .15);
      color: var(--red)
    }

    .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin .8s linear infinite;
      flex-shrink: 0
    }

    @keyframes spin {
      to {
        transform: rotate(360deg)
      }
    }

    .sleg {
      text-align: left;
      margin-top: 12px;
      padding: 10px;
      background: var(--bg);
      border-radius: 10px;
      font-size: .64rem;
      color: var(--muted);
      line-height: 1.7
    }

    .sleg b {
      color: var(--text)
    }

    /* Lobby footer */
    .lobby-footer {
      margin-top: 14px;
      text-align: center;
      font-size: .6rem;
      opacity: .5;
      color: var(--muted);
    }

    .lobby-footer a {
      color: var(--muted);
      text-decoration: none
    }

    .lobby-footer a:hover {
      color: var(--accent)
    }

    /* â”€â”€ Game â”€â”€ */
    .gw {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      width: 100%;
      max-width: 520px;
      padding: 4px 10px;
      height: 100dvh;
      height: -webkit-fill-available;
      justify-content: flex-start;
      overflow: hidden;
    }

    .cb {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: .65rem;
      font-weight: 600;
      flex-shrink: 0;
      color: var(--muted)
    }

    .cd {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      flex-shrink: 0
    }

    .cd.on {
      background: var(--green);
      box-shadow: 0 0 6px rgba(76, 175, 80, .5)
    }

    .cd.off {
      background: var(--red)
    }

    .hd {
      text-align: center;
      flex-shrink: 0
    }

    .hd h1 {
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 3px;
      color: var(--accent)
    }

    .hd .sub {
      font-size: .55rem;
      color: var(--muted);
      letter-spacing: 1px
    }

    /* â”€â”€ Score + Lives â”€â”€ */
    .sp {
      display: flex;
      align-items: stretch;
      gap: 8px;
      flex-shrink: 0;
      width: 100%;
      max-width: 460px
    }

    .pc {
      flex: 1;
      background: var(--card);
      border-radius: 10px;
      padding: 6px 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      border: 2px solid transparent;
      transition: border-color .3s;
      position: relative;
      overflow: hidden
    }

    .pc.act {
      border-color: var(--accent);
      box-shadow: 0 0 12px rgba(232, 168, 73, .12)
    }

    .pc.mo {
      outline: 2px solid var(--blue);
      outline-offset: -2px
    }

    .pc.act::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      animation: pb 1.5s ease-in-out infinite
    }

    @keyframes pb {

      0%,
      100% {
        opacity: .4
      }

      50% {
        opacity: 1
      }
    }

    .pc.hit {
      animation: hitShake .4s ease
    }

    @keyframes hitShake {

      0%,
      100% {
        transform: translateX(0)
      }

      20% {
        transform: translateX(-6px)
      }

      40% {
        transform: translateX(6px)
      }

      60% {
        transform: translateX(-4px)
      }

      80% {
        transform: translateX(4px)
      }
    }

    .si {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .4)
    }

    .si.bk {
      background: radial-gradient(circle at 35% 30%, #555, #1a1a1a 60%, #000)
    }

    .si.wh {
      background: radial-gradient(circle at 35% 30%, #fff, #e8e4dc 50%, #c8c0b4)
    }

    .pi {
      display: flex;
      flex-direction: column;
      min-width: 0
    }

    .pn {
      font-size: .65rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis
    }

    .lives {
      font-size: .7rem;
      line-height: 1;
      margin-top: 1px;
      letter-spacing: 1px
    }

    .lives .lost {
      opacity: .2
    }

    .mt {
      font-size: .48rem;
      background: var(--blue);
      color: #fff;
      padding: 1px 3px;
      border-radius: 3px;
      font-weight: 700;
      margin-left: 2px
    }

    .vs {
      font-size: .65rem;
      font-weight: 700;
      color: var(--muted);
      flex-shrink: 0
    }

    /* â”€â”€ Status â”€â”€ */
    .sb {
      background: var(--card);
      border-radius: 8px;
      padding: 4px 10px;
      font-size: .72rem;
      font-weight: 500;
      text-align: center;
      flex-shrink: 0;
      min-height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      max-width: 460px
    }

    .sd {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      animation: bl 1.2s ease-in-out infinite
    }

    @keyframes bl {

      0%,
      100% {
        opacity: .3
      }

      50% {
        opacity: 1
      }
    }

    /* â”€â”€ Board â”€â”€ */
    .bc {
      position: relative;
      flex-shrink: 0;
      aspect-ratio: 1/1;
      width: min(calc(100vw - 20px), calc(100dvh - 380px), 460px);
      align-self: center;
    }

    .bbg {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 30px rgba(0, 0, 0, .5), inset 0 1px 0 rgba(255, 255, 255, .08)
    }

    .bbg::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, transparent, transparent 18px, rgba(139, 105, 20, .08) 18px, rgba(139, 105, 20, .08) 20px), repeating-linear-gradient(0deg, transparent, transparent 40px, rgba(139, 105, 20, .06) 40px, rgba(139, 105, 20, .06) 42px);
      background-color: var(--board)
    }

    .bbg::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, .12), transparent 60%), radial-gradient(ellipse at 70% 80%, rgba(0, 0, 0, .08), transparent 60%)
    }

    canvas {
      position: relative;
      z-index: 2;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      cursor: pointer;
      touch-action: none;
      display: block
    }

    /* â”€â”€ Skills â”€â”€ */
    .skb {
      width: 100%;
      max-width: 460px;
      flex-shrink: 0
    }

    .skl {
      font-size: .6rem;
      color: var(--muted);
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      justify-content: space-between
    }

    .sks {
      display: flex;
      gap: 4px
    }

    .skt {
      flex: 1;
      background: var(--card);
      border: 2px solid var(--card2);
      border-radius: 8px;
      padding: 4px 2px;
      text-align: center;
      cursor: pointer;
      transition: border-color .2s, transform .15s;
      min-height: 38px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1px
    }

    .skt:hover:not(.empty) {
      border-color: var(--accent);
      transform: translateY(-2px)
    }

    .skt.empty {
      opacity: .3;
      cursor: default;
      border-style: dashed
    }

    .skt.sel {
      border-color: var(--purple);
      box-shadow: 0 0 10px rgba(168, 85, 247, .3);
      transform: translateY(-2px)
    }

    .skt .ki {
      font-size: .85rem;
      line-height: 1
    }

    .skt .kn {
      font-size: .42rem;
      font-weight: 600;
      color: var(--muted);
      line-height: 1
    }

    /* â”€â”€ Actions â”€â”€ */
    .ab {
      display: flex;
      gap: 5px;
      width: 100%;
      max-width: 460px;
      flex-shrink: 0
    }

    .abtn {
      flex: 1;
      padding: 7px 0;
      border: none;
      border-radius: 8px;
      font-family: inherit;
      font-size: .72rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform .15s, opacity .15s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      -webkit-appearance: none
    }

    .abtn:active {
      transform: scale(.96)
    }

    .abtn:disabled {
      opacity: .35;
      cursor: not-allowed
    }

    .abtn.pl {
      background: var(--accent);
      color: var(--bg)
    }

    .abtn.sk {
      background: var(--purple);
      color: #fff
    }

    .abtn.cn {
      background: var(--card2);
      color: var(--text)
    }

    .abtn.lv {
      background: var(--red);
      color: #fff;
      flex: .4
    }

    .abtn.rs {
      background: var(--card2);
      color: var(--text);
      flex: .7
    }

    /* â”€â”€ Chat â”€â”€ */
    .ca {
      width: 100%;
      max-width: 460px;
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .cms {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 1px;
      -webkit-overflow-scrolling: touch;
      background: var(--card);
      border-radius: 8px;
      padding: 6px 8px;
    }

    .cm {
      font-size: .63rem;
      color: var(--muted);
      padding: 1px 0;
      line-height: 1.4
    }

    .cm .sn {
      font-weight: 700;
      color: var(--accent)
    }

    .cm.sy {
      color: var(--blue);
      font-style: italic
    }

    .cr {
      display: flex;
      gap: 4px;
      flex-shrink: 0
    }

    .ci {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--card2);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: .68rem;
      outline: none;
      -webkit-appearance: none;
      min-height: 34px
    }

    .ci:focus {
      border-color: var(--accent)
    }

    .cs {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background: var(--accent);
      color: var(--bg);
      font-family: inherit;
      font-size: .68rem;
      font-weight: 600;
      cursor: pointer;
      -webkit-appearance: none;
      white-space: nowrap
    }

    /* â”€â”€ Overlays â”€â”€ */
    .ov {
      position: fixed;
      inset: 0;
      z-index: 100;
      background: rgba(0, 0, 0, .7);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .4s
    }

    .ov.show {
      opacity: 1;
      pointer-events: auto
    }

    .oc {
      background: var(--card);
      border-radius: 18px;
      padding: 26px 32px;
      text-align: center;
      transform: scale(.85);
      transition: transform .4s cubic-bezier(.34, 1.56, .64, 1);
      box-shadow: 0 20px 60px rgba(0, 0, 0, .5);
      max-width: 290px;
      width: 88%
    }

    .ov.show .oc {
      transform: scale(1)
    }

    .oe {
      font-size: 2.6rem;
      margin-bottom: 6px
    }

    .ot {
      font-size: 1.2rem;
      font-weight: 900;
      margin-bottom: 4px;
      color: var(--accent)
    }

    .os {
      font-size: .78rem;
      color: var(--muted);
      margin-bottom: 16px;
      line-height: 1.5
    }

    .ob {
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 10px;
      padding: 9px 26px;
      font-family: inherit;
      font-size: .82rem;
      font-weight: 700;
      cursor: pointer
    }

    /* â”€â”€ Skill Popup â”€â”€ */
    .spop {
      position: fixed;
      inset: 0;
      z-index: 150;
      background: rgba(0, 0, 0, .5);
      backdrop-filter: blur(3px);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .3s
    }

    .spop.show {
      opacity: 1;
      pointer-events: auto
    }

    .spc {
      background: var(--card);
      border-radius: 14px;
      padding: 20px;
      text-align: center;
      max-width: 240px;
      width: 82%;
      transform: scale(.9);
      transition: transform .3s cubic-bezier(.34, 1.56, .64, 1)
    }

    .spop.show .spc {
      transform: scale(1)
    }

    .spc .xi {
      font-size: 2.2rem;
      margin-bottom: 4px
    }

    .spc .xt {
      font-size: .9rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 3px
    }

    .spc .xd {
      font-size: .7rem;
      color: var(--muted);
      margin-bottom: 12px;
      line-height: 1.4
    }

    .spc .xb {
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      padding: 7px 20px;
      font-family: inherit;
      font-size: .75rem;
      font-weight: 600;
      cursor: pointer
    }

    /* â”€â”€ Life Lost Flash â”€â”€ */
    .life-flash {
      position: fixed;
      inset: 0;
      z-index: 90;
      background: rgba(200, 30, 30, .25);
      pointer-events: none;
      opacity: 0;
      transition: opacity .15s
    }

    .life-flash.show {
      opacity: 1
    }

    /* â”€â”€ Responsive â”€â”€ */
    @media(max-height:700px) {
      .gw {
        gap: 2px;
        padding: 2px 8px
      }

      .hd {
        display: none
      }

      .skt {
        min-height: 32px;
        padding: 2px 1px
      }

      .skt .ki {
        font-size: .75rem
      }

      .skt .kn {
        font-size: .38rem
      }
    }

    @media(max-height:600px) {
      .cb {
        display: none
      }

      .sp .pi .pn {
        font-size: .58rem
      }
    }

    /* â”€â”€ gw-left: mobile default (transparent passthrough) â”€â”€ */
    .gw-left {
      display: contents;
      /* on mobile, acts as if it doesn't exist */
    }

    /* â”€â”€ Desktop wide layout: chat panel on the right, centered â”€â”€ */
    @media(min-width:900px) {
      body {
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .gw {
        flex-direction: row;
        align-items: stretch;
        max-width: 960px;
        width: 100%;
        padding: 16px 20px;
        gap: 16px;
        height: min(100dvh, 840px);
        overflow: hidden;
      }

      /* left column: board + controls */
      .gw-left {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        flex: 0 0 auto;
        height: 100%;
        overflow: hidden;
      }

      /* right column: chat */
      .ca {
        flex: 1;
        min-width: 200px;
        max-width: 300px;
        min-height: 0;
        align-self: stretch;
      }

      .bc {
        width: min(calc(100dvh - 280px), 480px);
      }
    }
  </style>
</head>

<body>

  <!-- â•â•â• LOBBY â•â•â• -->
  <div class="lobby" id="lobby">
    <div class="lc">
      <h1>æŠ€èƒ½äº”å­æ£‹</h1>
      <div class="sub">SKILL GOMOKU v3 Â· åœ¨çº¿å¯¹æˆ˜</div>
      <div class="ls">
        <h3>ğŸ  åˆ›å»ºæˆ¿é—´</h3>
        <p style="font-size:.72rem;color:var(--muted);margin-bottom:6px">åˆ›å»ºæˆ¿é—´åï¼Œå°†æˆ¿é—´ç å‘ç»™æœ‹å‹</p>
        <button class="lb p" style="width:100%" id="btn-create" onclick="createRoom()">åˆ›å»ºæˆ¿é—´ï¼ˆæ‰§é»‘å…ˆè¡Œï¼‰</button>
      </div>
      <div id="room-created" style="display:none">
        <div class="rcd">
          <div class="code" id="my-room-code">----</div>
          <div class="hint">å°†æ­¤æˆ¿é—´ç å‘é€ç»™å¯¹æ‰‹</div>
        </div>
        <button class="lb s" style="width:100%" onclick="copyCode()">ğŸ“‹ å¤åˆ¶æˆ¿é—´ç </button>
        <div class="sm info" id="wait-msg">
          <div class="spinner"></div>ç­‰å¾…å¯¹æ‰‹åŠ å…¥...
        </div>
      </div>
      <div class="dv">æˆ–</div>
      <div class="ls">
        <h3>ğŸ® åŠ å…¥æˆ¿é—´</h3>
        <div class="lr">
          <input class="li" id="join-input" placeholder="è¾“å…¥æˆ¿é—´ç " maxlength="6" autocomplete="off" spellcheck="false">
          <button class="lb p" id="btn-join" onclick="joinRoom()">åŠ å…¥</button>
        </div>
      </div>
      <div id="lobby-status"></div>
      <div class="sleg">
        <b>âš¡ v3 è§„åˆ™ï¼š</b><br>
        â¤ï¸ æ¯äºº3æ¡å‘½ï¼Œäº”å­è¿ç  â†’ å¯¹æ–¹ä¸¢1å‘½ + æ£‹å­æ¶ˆé™¤ + å¯¹æ–¹è·å¾—è¡¥å¿æŠ€èƒ½<br>
        å‘½å…ˆè€—å®Œçš„ä¸€æ–¹è¾“ Â· æ¯å›åˆï¼šè½å­ æˆ– ä½¿ç”¨æŠ€èƒ½ï¼ˆäºŒé€‰ä¸€ï¼‰<br>
        å¼€å±€è·å¾—1ä¸ªæŠ€èƒ½ Â· æ¯3å›åˆè·å¾—1ä¸ª Â· æœ€å¤šæŒæœ‰<b>5ä¸ª</b><br><br>
        ğŸ’£ <b>ç‚¸å¼¹</b> â€” 3Ã—3èŒƒå›´ç§»é™¤å¯¹æ‰‹æ£‹å­<br>
        ğŸ§Š <b>å†°å†»</b> â€” 5Ã—5èŒƒå›´å†»ç»“ç©ºä½2å›åˆ<br>
        ğŸ”„ <b>äº¤æ¢</b> â€” å°†å¯¹æ‰‹ä¸€é¢—æ£‹å­å˜æˆå·±æ–¹<br>
        âš¡ <b>åŒå­</b> â€” ä¸€å›åˆè½ä¸¤é¢—å­<br>
        ğŸ›¡ï¸ <b>æŠ¤ç›¾</b> â€” é€‰å·±æ–¹: 3Ã—3ä¿æŠ¤3å›åˆï¼ˆå¯¹æ‰‹ä¸å¯è§ï¼‰ï¼›é€‰å¯¹æ–¹: ç›´æ¥ç§»é™¤ä¸€é¢—æ£‹å­<br>
        ğŸŒ§ï¸ <b>é™é›¨</b> â€” åœ¨5ä¸ªéšæœºç©ºä½ç”Ÿæˆå·±æ–¹æ£‹å­<br>
        ğŸ•µï¸ <b>å·æŠ€</b> â€” éšæœºå·èµ°å¯¹æ‰‹ä¸€ä¸ªæŠ€èƒ½
      </div>
      <div style="margin-top:10px;font-size:.6rem;color:var(--muted)">ğŸ”’ PeerJS (WebRTC) P2P è¿æ¥</div>
      <div class="lobby-footer">
        <a href="https://www.linkedin.com/in/sylvialiu928/" target="_blank" rel="noopener">Sylvia Liu</a>
      </div>
    </div>
  </div>

  <!-- â•â•â• GAME â•â•â• -->
  <div class="gw" id="gw">
    <!-- Left column (board + controls) -->
    <div class="gw-left" id="gw-left">
      <div class="cb"><span class="cd on" id="conn-dot"></span><span id="conn-text">å·²è¿æ¥</span><span
          style="margin-left:6px;color:var(--accent);font-size:.6rem">æˆ¿é—´: <span id="g-room">----</span></span></div>
      <div class="hd">
        <h1>æŠ€èƒ½äº”å­æ£‹</h1>
        <div class="sub">SKILL GOMOKU v3 Â· åœ¨çº¿å¯¹æˆ˜</div>
      </div>

      <div class="sp">
        <div class="pc act" id="pc-b">
          <div class="si bk"></div>
          <div class="pi">
            <span class="pn">â¬¤ é»‘æ–¹<span class="mt" id="me-b" style="display:none">æˆ‘</span></span>
            <span class="lives" id="lives-b">â¤ï¸â¤ï¸â¤ï¸</span>
          </div>
        </div>
        <span class="vs">VS</span>
        <div class="pc" id="pc-w">
          <div class="si wh"></div>
          <div class="pi">
            <span class="pn">â—‹ ç™½æ–¹<span class="mt" id="me-w" style="display:none">æˆ‘</span></span>
            <span class="lives" id="lives-w">â¤ï¸â¤ï¸â¤ï¸</span>
          </div>
        </div>
      </div>

      <div class="sb" id="status">ç­‰å¾…å¼€å§‹...</div>
      <div class="bc">
        <div class="bbg"></div><canvas id="board"></canvas>
      </div>

      <div class="skb">
        <div class="skl"><span>ğŸ’ æˆ‘çš„æŠ€èƒ½ (æœ€å¤š5ä¸ª)</span><span id="sk-info">ä¸‹æ¬¡è·å¾—: 3å›åˆå</span></div>
        <div class="sks" id="sk-slots">
          <div class="skt empty" id="sl-0"><span class="ki">â€”</span><span class="kn">ç©º</span></div>
          <div class="skt empty" id="sl-1"><span class="ki">â€”</span><span class="kn">ç©º</span></div>
          <div class="skt empty" id="sl-2"><span class="ki">â€”</span><span class="kn">ç©º</span></div>
          <div class="skt empty" id="sl-3"><span class="ki">â€”</span><span class="kn">ç©º</span></div>
          <div class="skt empty" id="sl-4"><span class="ki">â€”</span><span class="kn">ç©º</span></div>
        </div>
      </div>

      <div class="ab" id="ab">
        <button class="abtn pl" id="btn-pl" onclick="setMode('place')" disabled>â¬¤ è½å­</button>
        <button class="abtn sk" id="btn-sk" onclick="setMode('skill')" disabled>âš¡ ä½¿ç”¨æŠ€èƒ½</button>
        <button class="abtn cn" id="btn-cn" onclick="cancelAction()" style="display:none">âœ• å–æ¶ˆ</button>
        <button class="abtn rs" id="btn-rs" onclick="reqRestart()" style="display:none">ğŸ”„ é‡å¼€</button>
        <button class="abtn lv" onclick="leaveGame()">ğŸšª</button>
      </div>
    </div><!-- /gw-left -->

    <!-- Chat panel -->
    <div class="ca">
      <div class="cms" id="cms"></div>
      <div class="cr">
        <input class="ci" id="ci" placeholder="å‘é€æ¶ˆæ¯..." maxlength="100" autocomplete="off">
        <button class="cs" onclick="sendChat()">å‘é€</button>
      </div>
    </div>
  </div>

  <!-- â•â•â• OVERLAYS â•â•â• -->
  <div class="ov" id="win-ov">
    <div class="oc">
      <div class="oe" id="w-e">ğŸ‰</div>
      <div class="ot" id="w-t">è·èƒœï¼</div>
      <div class="os" id="w-s">å¯¹æ‰‹ç”Ÿå‘½è€—å°½ï¼</div>
      <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
        <button class="ob" id="win-restart-btn" onclick="reqRestart()">ğŸ”„ é‡å¼€</button>
        <button class="ob" style="background:var(--card2);color:var(--text)" onclick="closeWin()">å…³é—­</button>
      </div>
    </div>
  </div>
  <div class="spop" id="sk-pop">
    <div class="spc">
      <div class="xi" id="x-i">âš¡</div>
      <div class="xt" id="x-t">è·å¾—æŠ€èƒ½ï¼</div>
      <div class="xd" id="x-d">æè¿°</div><button class="xb" onclick="closeSP()">çŸ¥é“äº†</button>
    </div>
  </div>
  <div class="life-flash" id="lf"></div>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  SKILLS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const SK = {
      bomb: { id: 'bomb', icon: 'ğŸ’£', name: 'ç‚¸å¼¹', desc: 'ç§»é™¤3Ã—3èŒƒå›´å†…å¯¹æ‰‹æ£‹å­' },
      freeze: { id: 'freeze', icon: 'ğŸ§Š', name: 'å†°å†»', desc: 'å†»ç»“5Ã—5èŒƒå›´å†…ç©ºä½2å›åˆ' },
      swap: { id: 'swap', icon: 'ğŸ”„', name: 'äº¤æ¢', desc: 'å°†å¯¹æ‰‹ä¸€é¢—æ£‹å­å˜æˆå·±æ–¹' },
      double: { id: 'double', icon: 'âš¡', name: 'åŒå­', desc: 'ä¸€å›åˆè½ä¸¤é¢—å­' },
      shield: { id: 'shield', icon: 'ğŸ›¡ï¸', name: 'æŠ¤ç›¾', desc: 'é€‰å·±æ–¹: 3Ã—3ä¿æŠ¤3å›åˆï¼›é€‰å¯¹æ–¹: ç§»é™¤ä¸€é¢—æ£‹å­' },
      rain: { id: 'rain', icon: 'ğŸŒ§ï¸', name: 'é™é›¨', desc: 'åœ¨5ä¸ªéšæœºç©ºä½ç”Ÿæˆå·±æ–¹æ£‹å­' },
      steal: { id: 'steal', icon: 'ğŸ•µï¸', name: 'å·æŠ€', desc: 'éšæœºå·èµ°å¯¹æ‰‹ä¸€ä¸ªæŠ€èƒ½' },
    };
    const SK_IDS = Object.keys(SK);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  NETWORKING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let peer = null, conn = null, myRole = 0, roomCode = '', connected = false;
    let _heartbeatInterval = null, _heartbeatMissed = 0;
    const HEARTBEAT_MS = 5000, HEARTBEAT_MAX_MISSED = 3;
    function genCode() { const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let s = ''; for (let i = 0; i < 5; i++)s += c[Math.floor(Math.random() * c.length)]; return s }

    function createRoom() {
      const b = document.getElementById('btn-create'); b.disabled = true; b.textContent = 'è¿æ¥ä¸­...';
      document.getElementById('btn-join').disabled = true;
      roomCode = genCode();
      peer = new Peer('sgk3-' + roomCode, { ...PEER_CONFIG });
      peer.on('open', () => { document.getElementById('room-created').style.display = 'block'; document.getElementById('my-room-code').textContent = roomCode; b.textContent = 'ç­‰å¾…å¯¹æ‰‹...'; myRole = 1 });
      peer.on('connection', c => { conn = c; setupConn() });
      peer.on('error', err => {
        if (err.type === 'unavailable-id') { roomCode = genCode(); peer.destroy(); setTimeout(createRoom, 300); return }
        showLS('è¿æ¥å¤±è´¥: ' + err.type, 'err'); b.disabled = false; b.textContent = 'åˆ›å»ºæˆ¿é—´ï¼ˆæ‰§é»‘å…ˆè¡Œï¼‰'; document.getElementById('btn-join').disabled = false;
      });
    }

    function joinRoom() {
      const input = document.getElementById('join-input'), code = input.value.trim().toUpperCase();
      if (code.length < 4) { showLS('è¯·è¾“å…¥æœ‰æ•ˆçš„æˆ¿é—´ç ', 'err'); return }
      const b = document.getElementById('btn-join'); b.disabled = true; b.textContent = 'è¿æ¥ä¸­...';
      document.getElementById('btn-create').disabled = true;
      roomCode = code; myRole = 2;
      peer = new Peer(undefined, { ...PEER_CONFIG });
      peer.on('open', () => {
        conn = peer.connect('sgk3-' + code, { reliable: true, serialization: 'json' });
        conn.on('open', () => setupConn());
        conn.on('error', () => { showLS('è¿æ¥å¤±è´¥', 'err'); b.disabled = false; b.textContent = 'åŠ å…¥'; document.getElementById('btn-create').disabled = false });
      });
      peer.on('error', err => {
        showLS(err.type === 'peer-unavailable' ? 'æˆ¿é—´ä¸å­˜åœ¨' : 'è¿æ¥å¤±è´¥: ' + err.type, 'err');
        b.disabled = false; b.textContent = 'åŠ å…¥'; document.getElementById('btn-create').disabled = false;
      });
    }

    function startHeartbeat() {
      stopHeartbeat();
      _heartbeatMissed = 0;
      _heartbeatInterval = setInterval(() => {
        if (!conn || !conn.open) { stopHeartbeat(); return }
        _heartbeatMissed++;
        if (_heartbeatMissed > HEARTBEAT_MAX_MISSED) {
          stopHeartbeat();
          connected = false; updateConnUI();
          sysMsg('âš ï¸ è¿æ¥è¶…æ—¶ï¼Œæ­£åœ¨å°è¯•é‡è¿...');
          attemptReconnect();
          return;
        }
        try { conn.send({ type: 'ping', t: Date.now() }) } catch (e) { }
      }, HEARTBEAT_MS);
    }

    function stopHeartbeat() {
      if (_heartbeatInterval) { clearInterval(_heartbeatInterval); _heartbeatInterval = null }
    }

    let _reconnectTimer = null, _reconnectAttempts = 0;
    function attemptReconnect() {
      if (_reconnectTimer) return;
      _reconnectAttempts++;
      const delay = Math.min(3000 * _reconnectAttempts, 20000);
      sysMsg(`ğŸ”„ ${delay / 1000}ç§’åé‡è¿ (ç¬¬${_reconnectAttempts}æ¬¡)...`);
      _reconnectTimer = setTimeout(() => {
        _reconnectTimer = null;
        if (!peer || peer.destroyed) {
          sysMsg('âš ï¸ è¿æ¥å·²å…³é—­ï¼Œè¯·åˆ·æ–°é¡µé¢é‡æ–°å¼€å§‹');
          return;
        }
        if (myRole === 2) {
          // joiner reconnects
          try {
            conn = peer.connect('sgk3-' + roomCode, { reliable: true, serialization: 'json' });
            conn.on('open', () => {
              _reconnectAttempts = 0;
              connected = true; updateConnUI();
              startHeartbeat();
              sysMsg('âœ… é‡è¿æˆåŠŸï¼');
              conn.on('data', d => handleMsg(d));
              conn.on('close', () => { connected = false; updateConnUI(); stopHeartbeat(); sysMsg('âš ï¸ è¿æ¥å…³é—­'); attemptReconnect() });
              conn.on('error', () => { connected = false; updateConnUI(); stopHeartbeat(); sysMsg('âš ï¸ è¿æ¥é”™è¯¯'); attemptReconnect() });
            });
            conn.on('error', () => { sysMsg('é‡è¿å¤±è´¥ï¼Œç»§ç»­é‡è¯•...'); attemptReconnect() });
          } catch (e) { sysMsg('é‡è¿å¤±è´¥ï¼Œç»§ç»­é‡è¯•...'); attemptReconnect() }
        } else {
          sysMsg('âš ï¸ æˆ¿ä¸»æ— æ³•ä¸»åŠ¨é‡è¿ï¼Œè¯·ç­‰å¾…å¯¹æ‰‹é‡è¿æˆ–åˆ·æ–°é¡µé¢é‡æ–°å¼€å§‹');
        }
      }, delay);
    }

    function setupConn() {
      connected = true;
      if (_reconnectTimer) { clearTimeout(_reconnectTimer); _reconnectTimer = null }
      _reconnectAttempts = 0;
      conn.on('data', d => handleMsg(d));
      conn.on('close', () => { connected = false; updateConnUI(); stopHeartbeat(); sysMsg('âš ï¸ å¯¹æ‰‹å·²æ–­å¼€è¿æ¥'); if (document.getElementById('gw').style.display === 'flex') attemptReconnect() });
      conn.on('error', () => { connected = false; updateConnUI(); stopHeartbeat(); if (document.getElementById('gw').style.display === 'flex') attemptReconnect() });
      startHeartbeat();
      startGame();
    }

    function tx(m) { if (conn && conn.open) { try { conn.send(m) } catch (e) { connected = false; updateConnUI(); stopHeartbeat(); attemptReconnect(); } } }

    function handleMsg(d) {
      if (!d || !d.type) return;
      switch (d.type) {
        case 'ping': try { conn.send({ type: 'pong', t: d.t }) } catch (e) { } break;
        case 'pong': _heartbeatMissed = 0; break;
        case 'move': receiveMove(d.r, d.c); break;
        case 'skill': receiveSkill(d); break;
        case 'steal-result':
          // The victim returned the skill they lost â€” add it to our pile
          if (d.skill && mySkills.length < MAX_SKILLS) {
            mySkills.push({ id: d.skill });
            sfxSkill(); sysMsg(`ğŸ•µï¸ å·æŠ€æˆåŠŸï¼è·å¾—: ${SK[d.skill].icon}${SK[d.skill].name}`);
          } else if (d.skill === null) {
            sysMsg('ğŸ•µï¸ å·æŠ€ï¼šå¯¹æ‰‹æ²¡æœ‰æŠ€èƒ½ï¼Œç™½ç™½æµªè´¹äº†');
          }
          updateSkillSlots(); break;
        case 'chat': addChat('å¯¹æ‰‹', d.text); break;
        case 'restart-req': handleRestartReq(); break;
        case 'restart-ok': execRestart(); sysMsg('å¯¹æ‰‹åŒæ„é‡æ–°å¼€å§‹'); break;
        case 'restart-no': sysMsg('å¯¹æ‰‹æ‹’ç»äº†é‡å¼€'); break;
      }
    }

    function showLS(t, c) { document.getElementById('lobby-status').innerHTML = `<div class="sm ${c}">${t}</div>` }
    function copyCode() { navigator.clipboard.writeText(roomCode).then(() => sysMsg('æˆ¿é—´ç å·²å¤åˆ¶')).catch(() => prompt('è¯·æ‰‹åŠ¨å¤åˆ¶:', roomCode)) }
    function updateConnUI() { const d = document.getElementById('conn-dot'), t = document.getElementById('conn-text'); if (connected) { d.className = 'cd on'; t.textContent = 'å·²è¿æ¥' } else { d.className = 'cd off'; t.textContent = 'å·²æ–­å¼€' } }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  AUDIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let ac;
    function ea() {
      if (!ac) {
        ac = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (ac.state === 'suspended') ac.resume();
    }
    function tone(f, dur, type = 'sine', vol = .4) {
      try {
        ea();
        const o = ac.createOscillator(), g = ac.createGain();
        o.connect(g); g.connect(ac.destination);
        o.type = type; o.frequency.value = f;
        g.gain.setValueAtTime(vol, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(.001, ac.currentTime + dur);
        o.start(); o.stop(ac.currentTime + dur);
      } catch (e) { }
    }
    // Place sound louder (vol=.55)
    function sfxPlace() {
      tone(800, .08, 'sine', .55);
      tone(1000, .05, 'sine', .3);
    }
    function sfxWin() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => tone(f, .25, 'sine', .5), i * 120)) }
    function sfxNotify() { tone(600, .15, 'sine', .45); setTimeout(() => tone(800, .1, 'sine', .35), 100) }
    function sfxSkill() { tone(400, .15, 'square', .3); setTimeout(() => tone(600, .12, 'square', .25), 80); setTimeout(() => tone(900, .2, 'sine', .35), 160) }
    function sfxBomb() { tone(100, .4, 'sawtooth', .5); tone(60, .5, 'square', .4) }
    function sfxFreeze() { tone(1200, .3, 'sine', .3); tone(1500, .2, 'sine', .25) }
    function sfxSwap() { tone(500, .15, 'sine', .4); setTimeout(() => tone(700, .15, 'sine', .35), 120) }
    function sfxLifeLost() { tone(200, .5, 'sawtooth', .5); setTimeout(() => tone(120, .6, 'square', .45), 200) }
    function sfxDissolve() { [400, 350, 300, 250, 200].forEach((f, i) => setTimeout(() => tone(f, .15, 'sine', .3), i * 60)) }
    function sfxRain() {
      for (let i = 0; i < 5; i++)setTimeout(() => tone(600 + i * 80, .1, 'sine', .3), i * 80);
    }

    // Unlock audio on first touch (iOS Safari)
    document.addEventListener('touchstart', () => { ea() }, { once: true });
    document.addEventListener('click', () => { ea() }, { once: true });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  GAME STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const SZ = 15;
    let board = [];
    let current = 1;
    let hist = [];
    let gameOver = false;
    let lives = { 1: 3, 2: 3 };
    let hoverCell = { r: -1, c: -1 };
    let lastMove = null;
    let pendingFive = false;

    // Skill state
    let mySkills = [];
    const MAX_SKILLS = 5;
    let turnCount = { 1: 0, 2: 0 };
    let frozenCells = [];    // [{r,c,turnsLeft}]
    let shieldedCells = [];  // [{r,c,turnsLeft,owner}]

    // Interaction
    let mode = 'place';
    let selSkIdx = -1, selSkId = '';
    let dblFirst = null;

    // Animations
    let anims = [];
    let animFrame = 0;
    let animRunning = false;

    const canvas = document.getElementById('board'), ctx = canvas.getContext('2d');
    let cellSize, padding, boardPx;

    function startGame() {
      document.getElementById('lobby').classList.add('hidden');
      const gw = document.getElementById('gw');
      gw.style.display = 'flex';
      // On desktop (wide), use row layout and move left-column items into gw-left
      applyDesktopLayout();
      document.getElementById('g-room').textContent = roomCode;
      if (myRole === 1) { document.getElementById('me-b').style.display = 'inline'; document.getElementById('me-w').style.display = 'none' }
      else { document.getElementById('me-b').style.display = 'none'; document.getElementById('me-w').style.display = 'inline' }
      updateConnUI();
      sysMsg(myRole === 1 ? 'ä½ æ˜¯é»‘æ–¹ï¼ˆå…ˆæ‰‹ï¼‰ï¼Œå¯¹æ‰‹å·²åŠ å…¥ï¼' : 'ä½ æ˜¯ç™½æ–¹ï¼ˆåæ‰‹ï¼‰ï¼Œå·²è¿æ¥ï¼');
      initBoard();
    }

    function applyDesktopLayout() {
      // gw-left already contains the board and controls in the HTML.
      // On mobile the gw-left wrapper has no flex styling (falls back to normal flow).
      // On desktop CSS media query makes gw row and gw-left a column.
      // Nothing extra needed â€” CSS handles it.
    }

    function initBoard() {
      board = Array.from({ length: SZ }, () => Array(SZ).fill(0));
      hist = []; current = 1; gameOver = false; lastMove = null; hoverCell = { r: -1, c: -1 };
      lives = { 1: 3, 2: 3 }; pendingFive = false;
      mySkills = []; turnCount = { 1: 0, 2: 0 };
      frozenCells = []; shieldedCells = [];
      mode = 'place'; selSkIdx = -1; selSkId = ''; dblFirst = null; anims = [];
      grantSkill();
      updateAll(); resizeCanvas();
    }

    function resizeCanvas() {
      const ct = canvas.parentElement;
      const sz = Math.min(ct.clientWidth, ct.clientHeight);
      const dpr = window.devicePixelRatio || 1;
      canvas.width = sz * dpr; canvas.height = sz * dpr;
      canvas.style.width = sz + 'px'; canvas.style.height = sz + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      padding = sz * .055; boardPx = sz - padding * 2; cellSize = boardPx / (SZ - 1);
      draw();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  DRAWING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function draw() {
      animFrame++;
      const sz = parseFloat(canvas.style.width) || canvas.clientWidth || 300;
      ctx.clearRect(0, 0, sz, sz);
      drawGrid(sz); drawStars(); drawFrozen(); drawStones(); drawMyShields();
      if (!gameOver && !pendingFive && isMyTurn()) drawHover();
      drawAnims();
    }

    function drawGrid(sz) {
      ctx.strokeStyle = 'rgba(139,105,20,.55)'; ctx.lineWidth = 1;
      for (let i = 0; i < SZ; i++) {
        const p = padding + i * cellSize;
        ctx.beginPath(); ctx.moveTo(padding, p); ctx.lineTo(sz - padding, p); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p, padding); ctx.lineTo(p, sz - padding); ctx.stroke();
      }
    }

    function drawStars() {
      const pts = [3, 7, 11]; ctx.fillStyle = 'rgba(139,105,20,.7)';
      pts.forEach(r => pts.forEach(c => { ctx.beginPath(); ctx.arc(padding + c * cellSize, padding + r * cellSize, cellSize * .12, 0, Math.PI * 2); ctx.fill() }));
    }

    function drawFrozen() {
      for (const f of frozenCells) {
        const x = padding + f.c * cellSize, y = padding + f.r * cellSize, rad = cellSize * .44;
        ctx.save(); ctx.globalAlpha = .22 + Math.sin(animFrame * .08) * .06; ctx.fillStyle = '#60c0e8';
        ctx.beginPath(); ctx.arc(x, y, rad, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        ctx.save(); ctx.globalAlpha = .65; ctx.strokeStyle = '#a0e0ff'; ctx.lineWidth = 1.5;
        const s = cellSize * .2;
        for (let a = 0; a < 6; a++) { const ang = a * Math.PI / 3 + animFrame * .005; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(ang) * s, y + Math.sin(ang) * s); ctx.stroke() }
        ctx.restore();
        ctx.fillStyle = '#a0e0ff'; ctx.font = `bold ${Math.max(7, cellSize * .26)}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(f.turnsLeft + '', x, y);
      }
    }

    function drawStones() {
      for (let r = 0; r < SZ; r++) {
        for (let c = 0; c < SZ; c++) {
          if (board[r][c] === 0) continue;
          const owner = board[r][c], x = padding + c * cellSize, y = padding + r * cellSize, rad = cellSize * .43;
          const isLast = lastMove && lastMove[0] === r && lastMove[1] === c;
          ctx.save();
          ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = cellSize * .2; ctx.shadowOffsetX = cellSize * .04; ctx.shadowOffsetY = cellSize * .06;
          if (owner === 1) {
            const g = ctx.createRadialGradient(x - rad * .3, y - rad * .3, rad * .1, x, y, rad);
            g.addColorStop(0, '#666'); g.addColorStop(.4, '#333'); g.addColorStop(1, '#0a0a0a'); ctx.fillStyle = g;
          } else {
            const g = ctx.createRadialGradient(x - rad * .3, y - rad * .3, rad * .1, x, y, rad);
            g.addColorStop(0, '#fff'); g.addColorStop(.5, '#f0ece4'); g.addColorStop(1, '#c8c0b0'); ctx.fillStyle = g;
          }
          ctx.beginPath(); ctx.arc(x, y, rad, 0, Math.PI * 2); ctx.fill(); ctx.restore();
          if (isLast && !gameOver) {
            ctx.save(); ctx.fillStyle = 'rgba(232,168,73,.9)';
            ctx.beginPath(); ctx.arc(x, y, cellSize * .08, 0, Math.PI * 2); ctx.fill(); ctx.restore();
          }
        }
      }
    }

    function drawMyShields() {
      for (const s of shieldedCells) {
        if (s.owner !== myRole || board[s.r][s.c] === 0) continue;
        const x = padding + s.c * cellSize, y = padding + s.r * cellSize, rad = cellSize * .48;
        ctx.save(); ctx.globalAlpha = .35 + Math.sin(animFrame * .06) * .12;
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.shadowColor = 'rgba(255,215,0,.3)'; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.arc(x, y, rad, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
      }
    }

    function drawHover() {
      const { r, c } = hoverCell;
      if (r < 0 || c < 0 || r >= SZ || c >= SZ) return;
      const x = padding + c * cellSize, y = padding + r * cellSize;

      if (mode === 'place' || mode === 'dbl2') {
        if (board[r][c] !== 0 || isFrozen(r, c)) return;
        ctx.save(); ctx.globalAlpha = .3; ctx.fillStyle = myRole === 1 ? '#1a1a1a' : '#f0ece4';
        ctx.beginPath(); ctx.arc(x, y, cellSize * .43, 0, Math.PI * 2); ctx.fill(); ctx.restore();
      } else if (mode === 'sktgt') {
        ctx.save(); ctx.globalAlpha = .3;
        const opp = myRole === 1 ? 2 : 1;
        if (selSkId === 'bomb') {
          ctx.strokeStyle = '#ff4040'; ctx.lineWidth = 2;
          ctx.strokeRect(x - cellSize * 1.5, y - cellSize * 1.5, cellSize * 3, cellSize * 3);
          ctx.fillStyle = 'rgba(255,64,64,.08)'; ctx.fillRect(x - cellSize * 1.5, y - cellSize * 1.5, cellSize * 3, cellSize * 3);
        } else if (selSkId === 'freeze') {
          ctx.strokeStyle = '#60c0e8'; ctx.lineWidth = 2;
          ctx.strokeRect(x - cellSize * 2.5, y - cellSize * 2.5, cellSize * 5, cellSize * 5);
          ctx.fillStyle = 'rgba(96,192,232,.08)'; ctx.fillRect(x - cellSize * 2.5, y - cellSize * 2.5, cellSize * 5, cellSize * 5);
        } else if (selSkId === 'shield') {
          if (board[r][c] === opp) {
            // targeting opponent piece â€” show removal indicator
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(x, y, cellSize * .55, 0, Math.PI * 2); ctx.stroke();
            ctx.strokeStyle = '#ff4040'; ctx.lineWidth = 2;
            const d = cellSize * .3;
            ctx.moveTo(x - d, y - d); ctx.lineTo(x + d, y + d); ctx.stroke();
            ctx.moveTo(x + d, y - d); ctx.lineTo(x - d, y + d); ctx.stroke();
          } else {
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
            ctx.strokeRect(x - cellSize * 1.5, y - cellSize * 1.5, cellSize * 3, cellSize * 3);
            ctx.fillStyle = 'rgba(255,215,0,.08)'; ctx.fillRect(x - cellSize * 1.5, y - cellSize * 1.5, cellSize * 3, cellSize * 3);
          }
        } else {
          ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(x, y, cellSize * .5, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.restore();
      }
    }

    function drawAnims() {
      let hasAnims = false;
      for (let i = anims.length - 1; i >= 0; i--) {
        const a = anims[i]; a.t++; const p = a.t / a.maxT;
        if (p >= 1) { anims.splice(i, 1); continue }
        hasAnims = true;
        const x = padding + a.c * cellSize, y = padding + a.r * cellSize;
        ctx.save();
        if (a.type === 'bomb') {
          ctx.globalAlpha = (1 - p) * .5; ctx.fillStyle = '#ff4040';
          ctx.beginPath(); ctx.arc(x, y, cellSize * 2 * p, 0, Math.PI * 2); ctx.fill();
          for (let j = 0; j < 8; j++) { const ang = j * Math.PI / 4 + p * 2, dist = cellSize * 2.5 * p; ctx.fillStyle = `rgba(255,${100 + j * 20},0,${(1 - p) * .7})`; ctx.fillRect(x + Math.cos(ang) * dist - 2, y + Math.sin(ang) * dist - 2, 4, 4) }
        } else if (a.type === 'freeze') {
          ctx.globalAlpha = (1 - p) * .6; ctx.strokeStyle = '#a0e0ff'; ctx.lineWidth = 2;
          for (let j = 0; j < 8; j++) { const ang = j * Math.PI / 4 + p * 3, dist = cellSize * p * 2; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(ang) * dist, y + Math.sin(ang) * dist); ctx.stroke() }
        } else if (a.type === 'swap') {
          ctx.globalAlpha = (1 - p) * .5; ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(x, y, cellSize * .5 + cellSize * p, 0, Math.PI * 2); ctx.stroke();
        } else if (a.type === 'shield') {
          ctx.globalAlpha = (1 - p) * .4; ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(x, y, cellSize * .5 + cellSize * .5 * p, 0, Math.PI * 2); ctx.stroke();
        } else if (a.type === 'rain') {
          ctx.globalAlpha = (1 - p) * .6; ctx.fillStyle = '#4fa8e0';
          ctx.beginPath(); ctx.arc(x, y - cellSize * p * 2, cellSize * .3 * (1 - p * .5), 0, Math.PI * 2); ctx.fill();
        } else if (a.type === 'dissolve') {
          ctx.globalAlpha = (1 - p) * .7;
          const col = a.owner === 1 ? '#333' : '#e0dcd0';
          for (let j = 0; j < 12; j++) {
            const ang = j * Math.PI / 6 + p * 4 + a.seed * j;
            const dist = cellSize * p * 2, sz2 = cellSize * .15 * (1 - p);
            ctx.fillStyle = col; ctx.fillRect(x + Math.cos(ang) * dist - sz2 / 2, y + Math.sin(ang) * dist - sz2 / 2, sz2, sz2);
          }
        }
        ctx.restore();
      }
      if (hasAnims) {
        if (!animRunning) { animRunning = true; requestAnimationFrame(animLoop) }
      } else { animRunning = false }
    }

    function animLoop() { if (anims.length > 0) { draw(); requestAnimationFrame(animLoop) } else { animRunning = false; draw() } }
    function addAnim(type, r, c, dur = 40, extra = {}) { anims.push({ type, r, c, t: 0, maxT: dur, ...extra }); if (!animRunning) { animRunning = true; requestAnimationFrame(animLoop) } }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INTERACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function isMyTurn() { return current === myRole }
    function getCellFromPos(cx, cy) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = parseFloat(canvas.style.width) / rect.width;
      const scaleY = parseFloat(canvas.style.height) / rect.height;
      const bx = (cx - rect.left) * scaleX, by = (cy - rect.top) * scaleY;
      const c = Math.round((bx - padding) / cellSize), r = Math.round((by - padding) / cellSize);
      if (r < 0 || r >= SZ || c < 0 || c >= SZ) return null;
      return { r, c };
    }

    canvas.addEventListener('mousemove', e => {
      if (!isMyTurn() || gameOver || pendingFive) { hoverCell = { r: -1, c: -1 }; draw(); return }
      const cell = getCellFromPos(e.clientX, e.clientY);
      if (cell) { if (hoverCell.r !== cell.r || hoverCell.c !== cell.c) { hoverCell = cell; draw() } }
      else { hoverCell = { r: -1, c: -1 }; draw() }
    });
    canvas.addEventListener('mouseleave', () => { hoverCell = { r: -1, c: -1 }; draw() });

    function handleClick(cx, cy) {
      if (!isMyTurn() || gameOver || !connected || pendingFive) return;
      const cell = getCellFromPos(cx, cy); if (!cell) return;
      const { r, c } = cell;

      if (mode === 'place') {
        if (board[r][c] !== 0 || isFrozen(r, c)) return;
        localMove(r, c);
      } else if (mode === 'dbl1') {
        if (board[r][c] !== 0 || isFrozen(r, c)) return;
        board[r][c] = myRole; hist.push({ r, c, player: myRole, type: 'dbl1' }); lastMove = [r, c]; sfxPlace();
        dblFirst = { r, c };
        const w = checkFive(r, c, myRole);
        if (w) { mySkills.splice(selSkIdx, 1); tx({ type: 'skill', skill: 'double', targets: [{ r, c }] }); handleFive(w, myRole); return }
        mode = 'dbl2'; sysMsg('âš¡ åŒå­: è¯·è½ç¬¬äºŒé¢—å­'); updateAll(); draw();
      } else if (mode === 'dbl2') {
        if (board[r][c] !== 0 || isFrozen(r, c)) return;
        if (dblFirst && dblFirst.r === r && dblFirst.c === c) return;
        board[r][c] = myRole; hist.push({ r, c, player: myRole, type: 'dbl2' }); lastMove = [r, c]; sfxPlace();
        mySkills.splice(selSkIdx, 1);
        tx({ type: 'skill', skill: 'double', targets: [dblFirst, { r, c }] });
        addAnim('swap', r, c, 25); dblFirst = null; mode = 'place';
        const w = checkFive(r, c, myRole);
        if (w) { handleFive(w, myRole); return }
        endTurn();
      } else if (mode === 'sktgt') {
        execSkillTarget(r, c);
      }
    }

    canvas.addEventListener('click', e => handleClick(e.clientX, e.clientY));
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      const t = e.changedTouches[0];
      handleClick(t.clientX, t.clientY);
    }, { passive: false });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  CORE GAME LOGIC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function localMove(r, c) {
      placeStone(r, c, myRole);
      tx({ type: 'move', r, c });
      const w = checkFive(r, c, myRole);
      if (w) { handleFive(w, myRole); return }
      endTurn();
    }

    function receiveMove(r, c) {
      if (isMyTurn()) return;
      placeStone(r, c, current); sfxNotify();
      const w = checkFive(r, c, current);
      if (w) { handleFive(w, current); return }
      endTurn();
    }

    function placeStone(r, c, player) {
      if (gameOver || board[r][c] !== 0) return;
      board[r][c] = player; hist.push({ r, c, player, type: 'place' }); lastMove = [r, c]; sfxPlace(); draw();
    }

    function checkFive(r, c, p) {
      const dirs = [[0, 1], [1, 0], [1, 1], [1, -1]];
      for (const [dr, dc] of dirs) {
        let cells = [[r, c]];
        for (let i = 1; i < 5; i++) { const nr = r + dr * i, nc = c + dc * i; if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ || board[nr][nc] !== p) break; cells.push([nr, nc]) }
        for (let i = 1; i < 5; i++) { const nr = r - dr * i, nc = c - dc * i; if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ || board[nr][nc] !== p) break; cells.unshift([nr, nc]) }
        if (cells.length >= 5) return cells;
      }
      return null;
    }

    function checkBoardFive(p) {
      for (let r = 0; r < SZ; r++)for (let c = 0; c < SZ; c++) { if (board[r][c] === p) { const w = checkFive(r, c, p); if (w) return w } }
      return null;
    }

    function handleFive(cells, scorer) {
      const opponent = scorer === 1 ? 2 : 1;
      pendingFive = true;
      for (const [r, c] of cells) { addAnim('dissolve', r, c, 50, { owner: scorer, seed: Math.random() * 10 }) }
      sfxDissolve();
      setTimeout(() => {
        for (const [r, c] of cells) board[r][c] = 0;
        shieldedCells = shieldedCells.filter(s => !cells.some(([cr, cc]) => cr === s.r && cc === s.c));
        lives[opponent]--;
        flashLife(); sfxLifeLost();
        const cardId = opponent === 1 ? 'pc-b' : 'pc-w';
        const card = document.getElementById(cardId);
        card.classList.remove('hit'); void card.offsetWidth; card.classList.add('hit');
        sysMsg(`ğŸ’¥ ${scorer === 1 ? 'é»‘æ–¹' : 'ç™½æ–¹'}äº”å­è¿ç ï¼${opponent === 1 ? 'é»‘æ–¹' : 'ç™½æ–¹'}ä¸¢å¤±1æ¡å‘½ (å‰©ä½™${lives[opponent]})`);
        if (opponent === myRole && lives[opponent] > 0) { sysMsg('ğŸ ä½ è·å¾—äº†è¡¥å¿æŠ€èƒ½ï¼'); grantSkill() }
        else if (opponent !== myRole && lives[opponent] > 0) { sysMsg('ğŸ å¯¹æ‰‹è·å¾—äº†è¡¥å¿æŠ€èƒ½') }
        if (lives[opponent] <= 0) {
          gameOver = true; pendingFive = false; updateAll(); draw();
          setTimeout(() => { sfxWin(); showWin(scorer) }, 400);
          return;
        }
        pendingFive = false; updateAll(); draw(); endTurn();
      }, 550);
    }

    function flashLife() { const el = document.getElementById('lf'); el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 300) }

    function endTurn() {
      tickEffects();
      turnCount[current]++;
      if (current === myRole && turnCount[myRole] > 0 && turnCount[myRole] % 3 === 0) {
        setTimeout(() => grantSkill(), 200);
      }
      current = current === 1 ? 2 : 1;
      mode = 'place'; selSkIdx = -1; selSkId = ''; dblFirst = null;
      updateAll(); draw();
    }

    function tickEffects() {
      for (let i = frozenCells.length - 1; i >= 0; i--) { frozenCells[i].turnsLeft--; if (frozenCells[i].turnsLeft <= 0) frozenCells.splice(i, 1) }
      for (let i = shieldedCells.length - 1; i >= 0; i--) { shieldedCells[i].turnsLeft--; if (shieldedCells[i].turnsLeft <= 0) shieldedCells.splice(i, 1) }
    }

    function isFrozen(r, c) { return frozenCells.some(f => f.r === r && f.c === c) }
    function isShielded(r, c) { return shieldedCells.some(s => s.r === r && s.c === c) }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  SKILL SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function grantSkill() {
      if (mySkills.length >= MAX_SKILLS) return;
      const id = SK_IDS[Math.floor(Math.random() * SK_IDS.length)];
      mySkills.push({ id }); sfxSkill(); updateSkillSlots();
      const s = SK[id]; showSP(s.icon, `è·å¾—æŠ€èƒ½: ${s.name}`, s.desc);
    }

    function setMode(m) {
      if (!isMyTurn() || gameOver || pendingFive) return;
      if (m === 'place') { mode = 'place'; selSkIdx = -1; selSkId = ''; dblFirst = null; updateAll(); draw() }
      else if (m === 'skill') {
        if (mySkills.length === 0) { sysMsg('æ²¡æœ‰å¯ç”¨æŠ€èƒ½'); return }
        mode = 'skill'; updateAll(); sysMsg('è¯·é€‰æ‹©è¦ä½¿ç”¨çš„æŠ€èƒ½');
      }
    }

    function selectSkill(idx) {
      if (mode !== 'skill' || idx >= mySkills.length) return;
      selSkIdx = idx; selSkId = mySkills[idx].id;
      if (selSkId === 'double') {
        mode = 'dbl1'; dblFirst = null; sysMsg('âš¡ åŒå­: è¯·è½ç¬¬ä¸€é¢—å­');
      } else if (selSkId === 'rain') {
        // Rain: no target needed, execute immediately
        execRain();
      } else if (selSkId === 'steal') {
        // Steal: no target needed, execute immediately
        execSteal();
      } else {
        mode = 'sktgt';
        const hints = {
          bomb: 'ğŸ’£ ç‚¸å¼¹: é€‰æ‹©3Ã—3èŒƒå›´ä¸­å¿ƒ',
          freeze: 'ğŸ§Š å†°å†»: é€‰æ‹©5Ã—5èŒƒå›´ä¸­å¿ƒ',
          swap: 'ğŸ”„ äº¤æ¢: é€‰æ‹©å¯¹æ‰‹çš„ä¸€é¢—æ£‹å­',
          shield: 'ğŸ›¡ï¸ æŠ¤ç›¾: é€‰å·±æ–¹æ£‹å­åŒºåŸŸ æˆ– ç‚¹å¯¹æ‰‹æ£‹å­ç§»é™¤å®ƒ'
        };
        sysMsg(hints[selSkId] || 'é€‰æ‹©ç›®æ ‡');
      }
      updateAll(); draw();
    }

    function cancelAction() { mode = 'place'; selSkIdx = -1; selSkId = ''; dblFirst = null; updateAll(); draw() }

    function execSkillTarget(r, c) {
      const opp = myRole === 1 ? 2 : 1;

      if (selSkId === 'bomb') {
        const removed = [];
        for (let dr = -1; dr <= 1; dr++)for (let dc = -1; dc <= 1; dc++) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ) continue;
          if (board[nr][nc] === opp && !isShielded(nr, nc)) { board[nr][nc] = 0; removed.push({ r: nr, c: nc }) }
        }
        if (removed.length === 0) { sysMsg('è¯¥èŒƒå›´å†…æ²¡æœ‰å¯ç§»é™¤çš„å¯¹æ‰‹æ£‹å­'); return }
        sfxBomb(); addAnim('bomb', r, c, 45);
        mySkills.splice(selSkIdx, 1);
        tx({ type: 'skill', skill: 'bomb', r, c, removed });
        sysMsg(`ğŸ’£ ç‚¸å¼¹! ç§»é™¤äº†${removed.length}é¢—å¯¹æ‰‹æ£‹å­`);
        finishSkillTurn();

      } else if (selSkId === 'freeze') {
        // 5x5 range
        const frozen = [];
        for (let dr = -2; dr <= 2; dr++)for (let dc = -2; dc <= 2; dc++) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ) continue;
          if (board[nr][nc] === 0 && !isFrozen(nr, nc)) { frozenCells.push({ r: nr, c: nc, turnsLeft: 4 }); frozen.push({ r: nr, c: nc }) }
        }
        if (frozen.length === 0) { sysMsg('è¯¥èŒƒå›´å†…æ²¡æœ‰å¯å†»ç»“çš„ç©ºä½'); return }
        sfxFreeze(); addAnim('freeze', r, c, 35);
        mySkills.splice(selSkIdx, 1);
        tx({ type: 'skill', skill: 'freeze', r, c, frozen });
        sysMsg(`ğŸ§Š å†°å†»! å†»ç»“äº†${frozen.length}ä¸ªç©ºä½`);
        finishSkillTurn();

      } else if (selSkId === 'swap') {
        if (board[r][c] !== opp) { sysMsg('è¯·é€‰æ‹©å¯¹æ‰‹çš„ä¸€é¢—æ£‹å­'); return }
        if (isShielded(r, c)) { sysMsg('è¯¥æ£‹å­å—æŠ¤ç›¾ä¿æŠ¤ï¼'); return }
        board[r][c] = myRole; sfxSwap(); addAnim('swap', r, c, 30);
        mySkills.splice(selSkIdx, 1);
        tx({ type: 'skill', skill: 'swap', r, c });
        sysMsg('ğŸ”„ äº¤æ¢! å¯¹æ‰‹æ£‹å­å·²å˜ä¸ºå·±æ–¹');
        const w = checkBoardFive(myRole);
        if (w) { handleFive(w, myRole); return }
        finishSkillTurn();

      } else if (selSkId === 'shield') {
        // If clicking on opponent's piece â†’ remove it
        if (board[r][c] === opp) {
          if (isShielded(r, c)) { sysMsg('è¯¥æ£‹å­å—æŠ¤ç›¾ä¿æŠ¤ï¼'); return }
          board[r][c] = 0;
          sfxBomb(); addAnim('dissolve', r, c, 35, { owner: opp, seed: Math.random() * 10 });
          mySkills.splice(selSkIdx, 1);
          tx({ type: 'skill', skill: 'shield', r, c, mode: 'remove' });
          sysMsg('ğŸ›¡ï¸ æŠ¤ç›¾åè½¬! ç§»é™¤äº†å¯¹æ‰‹çš„æ£‹å­');
          finishSkillTurn();
        } else {
          // Shield own pieces in 3x3
          const shielded = [];
          for (let dr = -1; dr <= 1; dr++)for (let dc = -1; dc <= 1; dc++) {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ) continue;
            if (board[nr][nc] === myRole && !isShielded(nr, nc)) { shieldedCells.push({ r: nr, c: nc, turnsLeft: 6, owner: myRole }); shielded.push({ r: nr, c: nc }) }
          }
          if (shielded.length === 0) { sysMsg('è¯¥èŒƒå›´å†…æ²¡æœ‰å·±æ–¹æ£‹å­ï¼Œä¹Ÿæ²¡æœ‰å¯ç§»é™¤çš„å¯¹æ–¹æ£‹å­'); return }
          sfxSkill(); addAnim('shield', r, c, 30);
          mySkills.splice(selSkIdx, 1);
          tx({ type: 'skill', skill: 'shield', r, c, mode: 'protect', count: shielded.length });
          sysMsg(`ğŸ›¡ï¸ æŠ¤ç›¾! ä¿æŠ¤äº†${shielded.length}é¢—æ£‹å­ï¼ˆå¯¹æ‰‹ä¸å¯è§ï¼‰`);
          finishSkillTurn();
        }
      }
    }

    function execRain() {
      // Find all empty, non-frozen cells
      const emptyCells = [];
      for (let r = 0; r < SZ; r++)for (let c = 0; c < SZ; c++) {
        if (board[r][c] === 0 && !isFrozen(r, c)) emptyCells.push({ r, c });
      }
      if (emptyCells.length < 5) { sysMsg('ç©ºä½ä¸è¶³5ä¸ªï¼Œæ— æ³•ä½¿ç”¨é™é›¨'); return }
      // Shuffle and pick 5
      for (let i = emptyCells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]] }
      const chosen = emptyCells.slice(0, 5);
      for (const { r, c } of chosen) {
        board[r][c] = myRole;
        hist.push({ r, c, player: myRole, type: 'rain' });
        addAnim('rain', r, c, 30 + Math.random() * 20);
      }
      sfxRain(); lastMove = [chosen[chosen.length - 1].r, chosen[chosen.length - 1].c];
      mySkills.splice(selSkIdx, 1);
      tx({ type: 'skill', skill: 'rain', targets: chosen });
      sysMsg(`ğŸŒ§ï¸ é™é›¨! åœ¨5å¤„ç”Ÿæˆäº†å·±æ–¹æ£‹å­`);
      // Check for five
      for (const { r, c } of chosen) { const w = checkFive(r, c, myRole); if (w) { handleFive(w, myRole); return } }
      finishSkillTurn();
    }

    function execSteal() {
      if (mySkills.length === 0) { sysMsg('å·æŠ€å¤±è´¥: ä½ æ²¡æœ‰æŠ€èƒ½å¯å·'); return; }
      mySkills.splice(selSkIdx, 1);
      tx({ type: 'skill', skill: 'steal' });
      sfxSkill();
      sysMsg('ğŸ•µï¸ å·æŠ€! ç­‰å¾…å¯¹æ‰‹ç»“æœ...');
      finishSkillTurn();
    }

    function finishSkillTurn() {
      tickEffects(); turnCount[current]++;
      if (current === myRole && turnCount[myRole] > 0 && turnCount[myRole] % 3 === 0) {
        setTimeout(() => grantSkill(), 200);
      }
      current = current === 1 ? 2 : 1;
      mode = 'place'; selSkIdx = -1; selSkId = '';
      updateAll(); draw();
    }

    function receiveSkill(d) {
      const opp = myRole === 1 ? 2 : 1;

      if (d.skill === 'bomb') {
        for (const p of d.removed) board[p.r][p.c] = 0;
        shieldedCells = shieldedCells.filter(s => !d.removed.some(p => p.r === s.r && p.c === s.c));
        sfxBomb(); addAnim('bomb', d.r, d.c, 45);
        sysMsg(`å¯¹æ‰‹ä½¿ç”¨äº† ğŸ’£ ç‚¸å¼¹ï¼Œç§»é™¤äº†${d.removed.length}é¢—æ£‹å­`);
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();

      } else if (d.skill === 'freeze') {
        for (const f of d.frozen) frozenCells.push({ r: f.r, c: f.c, turnsLeft: 4 });
        sfxFreeze(); addAnim('freeze', d.r, d.c, 35);
        sysMsg(`å¯¹æ‰‹ä½¿ç”¨äº† ğŸ§Š å†°å†»ï¼Œå†»ç»“äº†${d.frozen.length}ä¸ªç©ºä½`);
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();

      } else if (d.skill === 'swap') {
        board[d.r][d.c] = opp;
        shieldedCells = shieldedCells.filter(s => !(s.r === d.r && s.c === d.c));
        sfxSwap(); addAnim('swap', d.r, d.c, 30);
        sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† ğŸ”„ äº¤æ¢');
        const w = checkBoardFive(opp);
        if (w) { handleFive(w, opp); return }
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();

      } else if (d.skill === 'double') {
        for (const t of d.targets) { board[t.r][t.c] = opp; hist.push({ r: t.r, c: t.c, player: opp, type: 'dbl' }); lastMove = [t.r, t.c] }
        sfxNotify(); sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† âš¡ åŒå­');
        for (const t of d.targets) { const w = checkFive(t.r, t.c, opp); if (w) { handleFive(w, opp); return } }
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();

      } else if (d.skill === 'shield') {
        if (d.mode === 'remove') {
          // Opponent used shield to remove our piece
          board[d.r][d.c] = 0;
          shieldedCells = shieldedCells.filter(s => !(s.r === d.r && s.c === d.c));
          sfxBomb(); addAnim('dissolve', d.r, d.c, 35, { owner: myRole, seed: Math.random() * 10 });
          sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† ğŸ›¡ï¸ æŠ¤ç›¾ï¼Œç§»é™¤äº†ä½ çš„ä¸€é¢—æ£‹å­ï¼');
        } else {
          // Opponent used shield to protect â€” reconstruct hidden shields
          for (let dr = -1; dr <= 1; dr++)for (let dc = -1; dc <= 1; dc++) {
            const nr = d.r + dr, nc = d.c + dc;
            if (nr < 0 || nr >= SZ || nc < 0 || nc >= SZ) continue;
            if (board[nr][nc] === opp) shieldedCells.push({ r: nr, c: nc, turnsLeft: 6, owner: opp });
          }
          sfxSkill(); sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† ğŸ›¡ï¸ æŠ¤ç›¾');
        }
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();

      } else if (d.skill === 'rain') {
        for (const t of d.targets) {
          board[t.r][t.c] = opp;
          hist.push({ r: t.r, c: t.c, player: opp, type: 'rain' });
          addAnim('rain', t.r, t.c, 30 + Math.random() * 20);
          if (t === d.targets[d.targets.length - 1]) lastMove = [t.r, t.c];
        }
        sfxRain(); sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† ğŸŒ§ï¸ é™é›¨');
        for (const t of d.targets) { const w = checkFive(t.r, t.c, opp); if (w) { handleFive(w, opp); return } }
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();
      } else if (d.skill === 'steal') {
        // Opponent used steal on us â€” pick a random skill from our list and send it back
        if (mySkills.length > 0) {
          const idx = Math.floor(Math.random() * mySkills.length);
          const stolen = mySkills.splice(idx, 1)[0];
          sfxSkill(); sysMsg(`å¯¹æ‰‹ä½¿ç”¨äº† ğŸ•µï¸ å·æŠ€ï¼Œå·èµ°äº†ä½ çš„ ${SK[stolen.id].icon}${SK[stolen.id].name}ï¼`);
          // Send the stolen skill back so the opponent can add it
          try { conn.send({ type: 'steal-result', skill: stolen.id }) } catch (e) { }
        } else {
          sfxSkill(); sysMsg('å¯¹æ‰‹ä½¿ç”¨äº† ğŸ•µï¸ å·æŠ€ï¼Œä½†ä½ æ²¡æœ‰æŠ€èƒ½è¢«å·');
          try { conn.send({ type: 'steal-result', skill: null }) } catch (e) { }
        }
        tickEffects(); turnCount[opp]++; current = current === 1 ? 2 : 1; updateAll(); draw();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  RESTART
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function reqRestart() { if (!connected) return; tx({ type: 'restart-req' }); sysMsg('å·²å‘é€é‡å¼€è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ‰‹ç¡®è®¤...') }
    function handleRestartReq() {
      sfxNotify();
      if (confirm('å¯¹æ‰‹è¯·æ±‚é‡æ–°å¼€å§‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
        tx({ type: 'restart-ok' }); execRestart(); sysMsg('æ–°ä¸€å±€å¼€å§‹ï¼');
      } else {
        tx({ type: 'restart-no' }); sysMsg('ä½ æ‹’ç»äº†é‡å¼€');
      }
    }
    function execRestart() { initBoard(); closeWin(); document.getElementById('btn-rs').style.display = 'none'; }
    function leaveGame() { if (confirm('ç¡®å®šè¦ç¦»å¼€ï¼Ÿ')) { stopHeartbeat(); if (_reconnectTimer) { clearTimeout(_reconnectTimer); _reconnectTimer = null } if (conn) conn.close(); if (peer) peer.destroy(); location.reload() } }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  CHAT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function sendChat() { const i = document.getElementById('ci'), t = i.value.trim(); if (!t || !connected) return; tx({ type: 'chat', text: t }); addChat('æˆ‘', t); i.value = '' }
    document.getElementById('ci').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendChat() } });
    function addChat(s, t) { const el = document.getElementById('cms'), d = document.createElement('div'); d.className = 'cm'; d.innerHTML = `<span class="sn">${esc(s)}:</span> ${esc(t)}`; el.appendChild(d); el.scrollTop = el.scrollHeight }
    function sysMsg(t) { const el = document.getElementById('cms'), d = document.createElement('div'); d.className = 'cm sy'; d.textContent = t; el.appendChild(d); el.scrollTop = el.scrollHeight }
    function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateAll() { updateLives(); updateStatus(); updateActions(); updateSkillSlots() }

    function updateLives() {
      for (const p of [1, 2]) {
        const el = document.getElementById(p === 1 ? 'lives-b' : 'lives-w');
        let html = '';
        for (let i = 0; i < 3; i++)html += i < lives[p] ? 'â¤ï¸' : '<span class="lost">ğŸ–¤</span>';
        el.innerHTML = html;
      }
      const cB = document.getElementById('pc-b'), cW = document.getElementById('pc-w');
      cB.classList.toggle('act', current === 1 && !gameOver);
      cW.classList.toggle('act', current === 2 && !gameOver);
      cB.classList.toggle('mo', myRole === 1);
      cW.classList.toggle('mo', myRole === 2);
    }

    function updateStatus() {
      const st = document.getElementById('status');
      if (!connected) { st.innerHTML = 'âš ï¸ <strong>è¿æ¥å·²æ–­å¼€</strong>'; return }
      if (gameOver) {
        const winner = lives[1] > 0 ? 1 : 2;
        const isMe = winner === myRole;
        st.innerHTML = `ğŸ† <strong>${winner === 1 ? 'é»‘æ–¹' : 'ç™½æ–¹'}</strong> è·èƒœï¼${isMe ? 'ï¼ˆä½ èµ¢äº†ï¼ï¼‰' : 'ï¼ˆä½ è¾“äº†ï¼‰'}`;
        return;
      }
      if (pendingFive) { st.innerHTML = 'ğŸ’¥ äº”å­è¿ç ï¼å¤„ç†ä¸­...'; return }
      const isMy = isMyTurn();
      const dotColor = current === 1 ? '#1a1a1a' : '#f0ece4';
      const border = current === 2 ? 'border:1px solid #666' : '';
      if (mode === 'sktgt' || mode === 'dbl1' || mode === 'dbl2' || mode === 'skill') {
        st.innerHTML = `<span class="sd" style="background:var(--purple)"></span> é€‰æ‹©æŠ€èƒ½ç›®æ ‡...`;
      } else {
        st.innerHTML = `<span class="sd" style="background:${dotColor};${border}"></span> ${isMy ? 'âœ¨ <strong>ä½ çš„å›åˆ</strong>' : 'ç­‰å¾…å¯¹æ‰‹...'}`;
      }
    }

    function updateActions() {
      const bp = document.getElementById('btn-pl'), bs = document.getElementById('btn-sk'), bc = document.getElementById('btn-cn'), br = document.getElementById('btn-rs');
      const isMy = isMyTurn() && !gameOver && connected && !pendingFive;
      if (mode === 'sktgt' || mode === 'dbl1' || mode === 'dbl2' || mode === 'skill') {
        bp.style.display = 'none'; bs.style.display = 'none'; bc.style.display = 'flex'; bc.disabled = false;
        br.style.display = 'none';
      } else {
        bp.style.display = 'flex'; bs.style.display = 'flex'; bc.style.display = 'none';
        bp.disabled = !isMy; bs.disabled = !isMy || mySkills.length === 0;
        br.style.display = gameOver ? 'flex' : 'none';
      }
      const myTurns = turnCount[myRole] || 0;
      const nextIn = 3 - (myTurns % 3);
      document.getElementById('sk-info').textContent = mySkills.length >= MAX_SKILLS ? 'æŠ€èƒ½æ§½å·²æ»¡' : `ä¸‹æ¬¡è·å¾—: ${nextIn === 3 && myTurns === 0 ? 3 : nextIn}å›åˆå`;
    }

    function updateSkillSlots() {
      for (let i = 0; i < MAX_SKILLS; i++) {
        const slot = document.getElementById('sl-' + i);
        if (!slot) continue;
        if (i < mySkills.length) {
          const s = SK[mySkills[i].id];
          slot.className = 'skt' + (selSkIdx === i ? ' sel' : '');
          slot.innerHTML = `<span class="ki">${s.icon}</span><span class="kn">${s.name}</span>`;
          slot.onclick = () => { if (mode === 'skill') selectSkill(i) };
        } else {
          slot.className = 'skt empty';
          slot.innerHTML = '<span class="ki">â€”</span><span class="kn">ç©º</span>';
          slot.onclick = null;
        }
      }
    }

    function showWin(winner) {
      const ov = document.getElementById('win-ov');
      const isMe = winner === myRole;
      document.getElementById('w-e').textContent = isMe ? 'ğŸ‰' : 'ğŸ˜”';
      document.getElementById('w-t').textContent = isMe ? 'ä½ èµ¢äº†ï¼' : 'ä½ è¾“äº†';
      document.getElementById('w-s').textContent = `${winner === 1 ? 'é»‘æ–¹' : 'ç™½æ–¹'}è·èƒœï¼å¯¹æ‰‹ç”Ÿå‘½è€—å°½`;
      ov.classList.add('show');
    }
    function closeWin() { document.getElementById('win-ov').classList.remove('show') }
    function showSP(icon, title, desc) { document.getElementById('x-i').textContent = icon; document.getElementById('x-t').textContent = title; document.getElementById('x-d').textContent = desc; document.getElementById('sk-pop').classList.add('show') }
    function closeSP() { document.getElementById('sk-pop').classList.remove('show') }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.addEventListener('resize', () => {
      if (document.getElementById('gw').style.display === 'flex') resizeCanvas();
    });
    window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 300));
    document.getElementById('join-input').addEventListener('input', e => { e.target.value = e.target.value.toUpperCase() });
    document.getElementById('join-input').addEventListener('keydown', e => { if (e.key === 'Enter') joinRoom() });

    // Keep connection alive: also send ping on page visibility restore
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && conn && conn.open) {
        _heartbeatMissed = 0;
        try { conn.send({ type: 'ping', t: Date.now() }) } catch (e) { }
      }
    });

    // Prevent rubber-banding on iOS
    document.addEventListener('touchmove', e => { if (e.target === document.body) e.preventDefault() }, { passive: false });
  </script>
</body>

</html>